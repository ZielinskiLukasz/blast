#!/usr/bin/env python
# -*- coding: utf-8 -*- 
#
# blast it (re: http://www.youtube.com/watch?v=nTqEgbVEYJA)
#

import os, sys
from flask import Flask, Response, render_template, url_for, send_from_directory, stream_with_context
from lib.scanner import DirScanner

DEBUG      = True
SECRET_KEY = 'ruxer'
USERNAME   = 'admin'
PASSWORD   = 'default'
REPATH_MAP = { '/': '___' }

app = Flask(__name__)
app.config.from_object(__name__)

@app.errorhandler(404)
def page_not_found(error):
    return render_template('404.html'), 404

@app.errorhandler(500)
def ise(error):
    return render_template('500.html'), 500

@app.route('/favicon.ico')
def favicon():
    return app.send_static_file('favicon.ico')

def path_replace(path, rules, reverse=False):
    for char, repl in rules.iteritems():
        if reverse: repl, char = char, repl
        path = path.replace(char, repl)
    return path

## courtesy of http://flask.pocoo.org/docs/patterns/streaming/
def stream_template(template_name, **context):
    app.update_template_context(context)
    t = app.jinja_env.get_template(template_name)
    rv = t.stream(context)
    rv.enable_buffering(5)
    return rv

def iterplayables():
    ''' fast iterator of playable file object/dicts found on disk
    '''
    ls = DirScanner()
    ## filter out just mp3 files (and dirs to support recursion)
    filt = lambda x: ( os.path.isdir(x) or x[-4:].lower() in ['.mp3', '.m4a'] )
    ## take the last two segments of the path as the label
    func = lambda x: '/'.join(x.split('/')[-2:])
    ## iterate over all the files (excluding dirs), filtering for .mp3 and .m4a
    for x,y in ls.iteritems(want_files=True, want_dirs=False, func=func, filt=filt):
        yield { 'name':      x.decode('utf-8'),
                'file_name': path_replace(y, REPATH_MAP).decode('utf-8') }

@app.route('/')
def play():
    return Response( stream_template( 'play.html', entries=stream_with_context(iterplayables()) ) )

@app.route('/play/<filename>')
def play_file(filename):
    filename = path_replace(filename, REPATH_MAP, reverse=True)
    if not os.path.exists(filename): print 'ERROR: %s doesn\'t exist' % filename
    base_dir, filename = os.path.dirname(filename), os.path.basename(filename)
    return send_from_directory(base_dir, filename)

#@app.route('/dupes')
#def dupes():
#    #searchword = request.args.get('key', '')
#    ls = DirScanner(os.getcwd())
#    entries = []
#    for x in ls.iterdupes():
#        entries.append( {'title': x[0], 'text': x[1]} )
#    return render_template('dupes.html', entries=entries)

def usage(bail=False):
    print ''' usage: cd /path/to/some/mp3s && blast
    
              options
              -------
                -h        Print this help screen
                -x        Run externally (otherwise binds only to localhost)
          '''
    if bail: sys.exit(0)

if __name__ == '__main__':
    if '-h' in sys.argv or '--help' in sys.argv: usage(bail=True)
    host = '0.0.0.0' if ('-x' in sys.argv) else '127.0.0.1'
    app.run(host=host)
